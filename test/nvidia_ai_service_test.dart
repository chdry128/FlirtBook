import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';
import 'package:flirtbook/girl_profile.dart';
import 'package:flirtbook/nvidia_ai_service.dart';
import 'package:flutter/foundation.dart' show kIsWeb; // To test kIsWeb behavior if necessary

// Generate mocks for http.Client
@GenerateMocks([http.Client])
import 'nvidia_ai_service_test.mocks.dart'; // This file will be generated by build_runner

void main() {
  late MockClient mockHttpClient;
  late NvidiaAIService nvidiaAIService;

  // Sample GirlProfile for testing
  final testProfile = GirlProfile(
    id: 'test_id',
    name: 'Nvidia Test',
    status: 'Friend',
    interests: ['ai', 'testing'],
  );
  const testTone = 'romantic';
  const testContext = 'at a cafe';

  setUp(() {
    mockHttpClient = MockClient();
    nvidiaAIService = NvidiaAIService(client: mockHttpClient);
  });

  group('NvidiaAIService - generateFlirtyMessage', () {
    test('Successful response from proxy', () async {
      // ARRANGE
      final expectedApiResponse = {
        "choices": [
          {
            "message": {"content": "This is a flirty message from NVIDIA via proxy."}
          }
        ]
      };
      final expectedReturnedMessage = "This is a flirty message from NVIDIA via proxy.";

      // Determine URI based on kIsWeb (can test one path, e.g., non-web)
      // For unit testing, we usually pick one execution path or test both if logic differs significantly.
      // Let's assume a non-web (mobile) path for this test, so full URL.
      final expectedUri = Uri.parse('http://localhost:3000/api/nvidia');
      
      when(mockHttpClient.post(
        expectedUri,
        headers: anyNamed('headers'),
        body: anyNamed('body'),
      )).thenAnswer((_) async => http.Response(jsonEncode(expectedApiResponse), 200));

      // ACT
      final result = await nvidiaAIService.generateFlirtyMessage(
        profile: testProfile,
        tone: testTone,
        context: testContext,
      );

      // ASSERT
      expect(result, expectedReturnedMessage);

      final verificationResult = verify(mockHttpClient.post(
        expectedUri,
        headers: captureAnyNamed('headers'),
        body: captureAnyNamed('body'),
      ));
      verificationResult.called(1);

      // Verify headers
      final capturedHeaders = verificationResult.captured[0] as Map<String, String>;
      expect(capturedHeaders['Content-Type'], 'application/json');
      expect(capturedHeaders['Accept'], 'application/json');
      expect(capturedHeaders.containsKey('Authorization'), isFalse, reason: "Authorization header should not be set by client");

      // Verify body
      final capturedBody = jsonDecode(verificationResult.captured[1] as String) as Map<String, dynamic>;
      expect(capturedBody['model'], 'meta/llama-4-scout-17b-16e-instruct');
      expect(capturedBody['messages'], isA<List>());
      expect(capturedBody['messages'].length, 1);
      expect(capturedBody['messages'][0]['role'], 'user');
      expect(capturedBody['messages'][0]['content'], contains(testProfile.name));
      expect(capturedBody['messages'][0]['content'], contains(testTone));
      expect(capturedBody['messages'][0]['content'], contains(testContext));
      expect(capturedBody['max_tokens'], 120);
      expect(capturedBody['stream'], false);
    });

    test('Error response from proxy (e.g., 500)', () async {
      // ARRANGE
      final expectedUri = Uri.parse('http://localhost:3000/api/nvidia'); // Assuming mobile path
      final errorBody = jsonEncode({"error": "Proxy error"});

      when(mockHttpClient.post(
        expectedUri,
        headers: anyNamed('headers'),
        body: anyNamed('body'),
      )).thenAnswer((_) async => http.Response(errorBody, 500));

      // ACT & ASSERT
      expect(
        () async => await nvidiaAIService.generateFlirtyMessage(
          profile: testProfile,
          tone: testTone,
          context: testContext,
        ),
        throwsA(isA<Exception>().having(
          (e) => e.toString(),
          'message',
          contains('Proxy request failed: 500 $errorBody'),
        )),
      );
       verify(mockHttpClient.post(
        expectedUri,
        headers: anyNamed('headers'),
        body: anyNamed('body'),
      )).called(1);
    });

     test('Failure to connect to proxy (network error)', () async {
      // ARRANGE
      final expectedUri = Uri.parse('http://localhost:3000/api/nvidia'); // Assuming mobile path
      
      when(mockHttpClient.post(
        expectedUri,
        headers: anyNamed('headers'),
        body: anyNamed('body'),
      )).thenThrow(http.ClientException("Failed to connect")); // Simulate network error

      // ACT & ASSERT
       expect(
        () async => await nvidiaAIService.generateFlirtyMessage(
          profile: testProfile,
          tone: testTone,
          context: testContext,
        ),
        throwsA(isA<Exception>().having(
          (e) => e.toString(),
          'message',
          contains('Failed to connect to the proxy server'),
        ).having(
          (e) => e.toString(),
          'original_exception',
          contains('ClientException: Failed to connect')
        )),
      );
       verify(mockHttpClient.post(
        expectedUri,
        headers: anyNamed('headers'),
        body: anyNamed('body'),
      )).called(1);
    });

    test('Proxy returns 200 but malformed JSON (missing choices)', () async {
      // ARRANGE
      final malformedApiResponse = {"not_choices": []}; // Missing 'choices'
      final expectedUri = Uri.parse('http://localhost:3000/api/nvidia');
      
      when(mockHttpClient.post(
        expectedUri,
        headers: anyNamed('headers'),
        body: anyNamed('body'),
      )).thenAnswer((_) async => http.Response(jsonEncode(malformedApiResponse), 200));

      // ACT
      final result = await nvidiaAIService.generateFlirtyMessage(
        profile: testProfile,
        tone: testTone,
        context: testContext,
      );

      // ASSERT
      expect(result, "Could not extract message from AI response.");
    });

  });
}

// Note: Run `flutter pub run build_runner build --delete-conflicting-outputs` to generate mocks.
