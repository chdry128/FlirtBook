import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:flirtbook/girl_profile.dart';
import 'package:flirtbook/history_model.dart';
import 'package:flirtbook/nvidia_ai_service.dart';
import 'package:flirtbook/openai_service.dart';
import 'package:flirtbook/shared_preference.dart';

// Generate mocks for dependencies
@GenerateMocks([NvidiaAIService, SharedPrefs, Connectivity])
import 'openai_service_test.mocks.dart'; // This file will be generated by build_runner

void main() {
  late MockNvidiaAIService mockNvidiaAIService;
  late MockSharedPrefs mockSharedPrefs;
  late MockConnectivity mockConnectivity;
  late OpenAIService openAIService;

  // Sample GirlProfile for testing
  final testProfile = GirlProfile(
    id: 'test_id',
    name: 'Test Girl',
    status: 'Crush',
    interests: ['testing', 'dart'],
  );
  const testTone = 'funny';
  const testContext = 'we just met';
  const aiMessage = "Successful AI message from NVIDIA";

  setUp(() {
    mockNvidiaAIService = MockNvidiaAIService();
    mockSharedPrefs = MockSharedPrefs();
    mockConnectivity = MockConnectivity();
    
    openAIService = OpenAIService(
      nvidiaAI: mockNvidiaAIService,
      sharedPrefs: mockSharedPrefs,
      connectivity: mockConnectivity,
    );
  });

  group('OpenAIService - generateFlirtyMessage', () {
    test('Scenario 1: Successful NVIDIA AI Response when online', () async {
      // ARRANGE
      when(mockConnectivity.checkConnectivity()).thenAnswer((_) async => [ConnectivityResult.wifi]);
      when(mockNvidiaAIService.generateFlirtyMessage(
        profile: testProfile,
        tone: testTone,
        context: testContext,
      )).thenAnswer((_) async => aiMessage);
      // Ensure saveProfile doesn't throw and completes.
      when(mockSharedPrefs.saveProfile(any, any)).thenAnswer((_) async {});

      // ACT
      final result = await openAIService.generateFlirtyMessage(
        testProfile,
        testTone,
        context: testContext,
      );

      // ASSERT
      expect(result, aiMessage);
      verify(mockNvidiaAIService.generateFlirtyMessage(
        profile: testProfile,
        tone: testTone,
        context: testContext,
      )).called(1);
      // Verify that _saveMessageHistory (which calls _sharedPrefs.saveProfile) was called.
      // We check that saveProfile was called with a key starting with 'history_' and any JSON map.
      verify(mockSharedPrefs.saveProfile(
          argThat(startsWith('history_')), argThat(isA<Map<String, dynamic>>()))).called(1);
    });

    test('Scenario 2: NVIDIA AI Fails, Fallback to Local Simulation when online', () async {
      // ARRANGE
      when(mockConnectivity.checkConnectivity()).thenAnswer((_) async => [ConnectivityResult.wifi]);
      when(mockNvidiaAIService.generateFlirtyMessage(
        profile: testProfile,
        tone: testTone,
        context: testContext,
      )).thenThrow(Exception("NVIDIA API Error")); // Simulate API failure
      when(mockSharedPrefs.saveProfile(any, any)).thenAnswer((_) async {});

      // ACT
      final result = await openAIService.generateFlirtyMessage(
        testProfile,
        testTone,
        context: testContext,
      );

      // ASSERT
      // Check if the result is one of the fallback messages.
      // This is a bit brittle if the fallback messages change frequently.
      // A more robust test might check for certain keywords or structure if possible.
      expect(result, isNotEmpty);
      expect(result, isNot(aiMessage)); // Ensure it's not the AI message
      expect(result, contains(testProfile.name)); // Fallback messages usually include the name
      if (testContext.isNotEmpty) {
         expect(result, contains(testContext));
      } else {
         expect(result, contains(testProfile.interests[0]));
      }
      
      verify(mockNvidiaAIService.generateFlirtyMessage(
        profile: testProfile,
        tone: testTone,
        context: testContext,
      )).called(1);
      verify(mockSharedPrefs.saveProfile(
          argThat(startsWith('history_')), argThat(isA<Map<String, dynamic>>()))).called(1);
    });
    
    test('Scenario 2b: NVIDIA AI returns empty message, Fallback to Local Simulation when online', () async {
      // ARRANGE
      when(mockConnectivity.checkConnectivity()).thenAnswer((_) async => [ConnectivityResult.wifi]);
      when(mockNvidiaAIService.generateFlirtyMessage(
        profile: testProfile,
        tone: testTone,
        context: testContext,
      )).thenAnswer((_) async => ""); // Simulate AI returning empty
      when(mockSharedPrefs.saveProfile(any, any)).thenAnswer((_) async {});

      // ACT
      final result = await openAIService.generateFlirtyMessage(
        testProfile,
        testTone,
        context: testContext,
      );

      // ASSERT
      expect(result, isNotEmpty);
      expect(result, isNot(aiMessage)); 
      expect(result, contains(testProfile.name));
       if (testContext.isNotEmpty) {
         expect(result, contains(testContext));
      } else {
         expect(result, contains(testProfile.interests[0]));
      }
      
      verify(mockNvidiaAIService.generateFlirtyMessage(
        profile: testProfile,
        tone: testTone,
        context: testContext,
      )).called(1);
      verify(mockSharedPrefs.saveProfile(
          argThat(startsWith('history_')), argThat(isA<Map<String, dynamic>>()))).called(1);
    });

    test('Scenario 3: Offline, Fallback to Local Simulation', () async {
      // ARRANGE
      when(mockConnectivity.checkConnectivity()).thenAnswer((_) async => [ConnectivityResult.none]);
      // No need to mock _nvidiaAIService.generateFlirtyMessage as it shouldn't be called.
      when(mockSharedPrefs.saveProfile(any, any)).thenAnswer((_) async {});

      // ACT
      final result = await openAIService.generateFlirtyMessage(
        testProfile,
        testTone,
        context: testContext,
      );

      // ASSERT
      expect(result, isNotEmpty);
      expect(result, isNot(aiMessage));
      expect(result, contains(testProfile.name));
       if (testContext.isNotEmpty) {
         expect(result, contains(testContext));
      } else {
         expect(result, contains(testProfile.interests[0]));
      }

      verifyNever(mockNvidiaAIService.generateFlirtyMessage(
        profile: anyNamed('profile'),
        tone: anyNamed('tone'),
        context: anyNamed('context'),
      ));
      verify(mockSharedPrefs.saveProfile(
          argThat(startsWith('history_')), argThat(isA<Map<String, dynamic>>()))).called(1);
    });
  });
}
